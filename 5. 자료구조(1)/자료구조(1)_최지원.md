# 5. 자료구조
## 5.1 복잡도
### 5.1.1 시간 복잡도
시간 복잡도는, 어떠한 알고리즘을 수행하는데 걸리는 시간을 설명하는데 쓰입니다. 시간 복잡도의 분석은 알고리즘의 primitive operation의 횟수를 세는것으로 이루어집니다.
>primitive operation이란? CPU가 수행하는 가장 기초적인 연산으로 +, - 와 같은 사칙연산과 >, = 와 같은 논리연산이 있습니다.
시간복잡도의 표현은 big-o notation(빅오 표기법)으로 이루어집니다.    

*big-o notation*   


![image](https://user-images.githubusercontent.com/103945439/194541600-50064ce1-ce22-4f6d-8945-79011a7bfa95.png)




보통의 경우 알고리즘의 시간 복잡도 분석은 최악의 경우(Worst case)를 가정하고 분석하게 됩니다. Worst case analysis를 제외하고 그 다음으로 많이 쓰이는 분석으로 평균 수행 시간 분석(Average case time complexity)가 있습니다. 

**Quick sork**  
Worst-case와 Average-case complexity가 다른 가장 대표적인 알고리즘으로 quick sort가 있습니다. quick sort의 최악 수행시간은 O(n^2)이지만, 평균 수행시간의 경우 O(nlogn)의 수행시간을 가집니다.

최악 수행시간이 O(n^2)임에도 불구하고, quick sort는 실제 연산 수행 시 최악 수행시간이 O(nlogn)인 정렬 알고리즘보다도 더 뛰어난 성능을 보입니다. 그 이유는 quick sort에서의 최악의 경우인 pivot이 가장 크거나 가장 작은 원소로 결정되는 경우의 확률이 매우 작기 때문입니다.

### 5.1.2 공간 복잡도
공간 복잡도란 프로그램을 수행시켰을때 필요한 메모리 공간의 크기를 의미합니다.
```c++
int* arr = new int[n]; /// 공간복잡도가 O(n) 이라고 할 수 있음
```

>시간 복잡도와 공간 복잡도의 관계는 많은 상황에서 trade-off라고 할 수 있습니다. 이것은 적은 시간이 걸리는 알고리즘은 많은 메모리 공간을 필요로 하고, 반대로 적은 메모리 공간만을 필요로 하는 알고리즘은 비교적 긴 수행시간을 가질것이라는 뜻을 의미합니다.   

시간 복잡도와 공간 복잡도는 어떠한 자료구조 또는 알고리즘의 성능 분석 및 개선의 척도가 되므로 매우 중요하다고 할 수 있습니다.

## 5.2 선형 자료구조
### 5.2.1 연결 리스트
연결 리스트는 데이터를 감싼 노드를 연결해 공간적 효율성을 극대화한 자료구조입니다.

연결 리스트는 필요한 최소한의 공간만을 사용하므로 공간적 효율성이 뛰어납니다. 또한, 데이터의 삽입과 삭제가 빠르다는 장점도 있습니다. 하지만, 자료의 탐색에 있어서 처음 노드부터 선형적으로 탐색해야된다는 단점이 있습니다.

### 5.2.2 배열
배열은 같은 데이터 타입의 변수들을 인접한 메모리 공간에 모아놓은 자료구조입니다.

배열의 가장 큰 장점은 상수 시간에 랜덤 접근이 가능하다는 점에 있습니다. 따라서 배열의 경우 자주 접근하는 자료구조가 필요할 때 쓰이는 것이 적합하다고 할 수 있습니다.


*랜덤 접근, 순차적 접근*   
랜덤 접근은 동일한 시간에 배열과 같은 순차적인 데이터가 있을 때 임의의 인덱스에 해당하는 데이터에 접근할 수 있는 기능입니다. 순차적 접근은 랜덤 접근에 반대되는 개념이라고 할 수 있습니다.

### 5.2.3 벡터
배열에서 진화한 형태의 벡터라고 하는 자료구조가 있습니다. 벡터의 특징으로는 벡터에 들어가는 데이터의 양에 따라 알아서 크기를 조정한다는 것입니다. 정해진 크기가 결정되면 그 크기를 바꿀 수 없는 배열과 대조적입니다. 

벡터는 데이터가 모두 찰때마다 원래크기의 2배로 자신의 크기를 늘립니다. 크기를 늘리는 작업 자체는 선형 시간이 걸리지만, amortized analysis에 따르면 전체적인 시간은 상수 시간에 수렴한다고 알려져 있습니다.

### 5.2.4 스택
스택은 가장 마지막으로 들어간 데이터가 가장 먼저 나오는 LIFO(Last In, First Out)의 성질을 가진 자료구조입니다. 

### 5.2.5 큐
큐는 먼저 들어간 데이터가 가장 먼저 나오는 FIFO(First In, First Out)의 성질을 가진 자료구조입니다. 


참고로 스택의 pop과 큐의 pop의 기능을 모두 가지고 있는 자료구조를 덱(deque)이라고 합니다.

## 5.3 비선형 자료구조
### 5.3.1 그래프
그래프는 정점과 간선으로 이루어진 자료 구조를 말합니다. 

어떤 곳에서 다른 곳으로 간다고 할 때 정점을 장소에 비유할 수 있고 간선은 가는 길로 비유할 수 있습니다.

어떠한 두 정점이 있고 이를 잇는 것이 간선입니다. 이러한 정점들과 간선들의 집합을 그래프라고 합니다.

**Definitions**   
1. Directed, undirected
> 그래프의 간선이 방향이 있는 경우를 directed graph라고 하고, 방향이 없는 경우를 undirected라고 합니다.

2. Complete graph   
> 그래프에서 모든 정점들 사이에 간선이 존재한다면, 그 그래프를 complete graph라고 합니다

3. Connected, Strongly connected
> 그래프에서 임의의 모든 정점에 대하여 간선을 통해 한 정점에 가서 다른 정점으로 갈 수 있다면 이 그래프는 connected라고 할 수 있습니다. Directed graph에서는 특별히 이러한 특징을 가진 그래프를 strongly connected라고 합니다

4. Cycle, acyclic
> 그래프에서 임의의 정점에서 시작해 다른 정점을 지나 다시 처음 출발한 정점으로 돌아오는 경로가 존재할 때 그 그래프에 cycle이 존재한다고 할 수 있습니다. 반대의 경우 acyclic이라고 합니다.

### 5.3.2 트리
그래프 중 undirected, connected, acyclic 그래프를 트리라고 합니다. 



트리는 root부터 시작해 부모 노드와 자식 노드가 존재하는 계층적 구조를 이루고 있다고 할 수 있습니다. 또한, 트리는 간선의 수가 항상 (노드의 수) - 1개 입니다.    

connected & acyclic <-> V - 1 = E (필요충분조건)

#### 이진 트리
이진 트리란 자식 노드의 수가 2개 이하인 트리를 의미합니다.

*균형 이진 트리*   
트리의 모든 서브트리에 대해서 오른쪽 서브트리와 왼쪽 서브트리의 높이 차이가 1 이하인 트리를 말합니다. 

#### 이진 탐색 트리
이진 탐색 트리(Binary Search Tree)는 노드의 오른쪽 서브트리의 노드에는 노드 값보다 큰 값을 가지는 노드만 존재하고 왼쪽에는 더 작은 값의 노드만 존재하는 트리를 말합니다.

이진 탐색 트리는 이름에서 알 수 있듯이 탐색에 최적인 트리입니다. 이진 탐색 트리에서의 탐색은 보통의 경우 O(logn)의 시간 복잡도를 가집니다. 하지만 트리의 불균형이 일어나 한쪽 서브트리에 데이터가 몰리면 O(n)의 시간 복잡도를 가지게 됩니다. 이 현상을 막기 위해 균형 이진 탐색 트리가 필요하게 되었습니다.

#### AVL 트리
AVL 트리는 이진 균형 탐색 트리로 불균형의 발생시 트리의 서브트리를 회전하여 균형을 유지합니다. 항상 균형을 유지하므로
O(logn)의 탐색 시간을 유지합니다. 

#### 레드 블랙 트리
레드 블랙 트리는 이진 균형 탐색 트리로 트리의 노드들을 레드 노드와 블랙 노드로 구분해 트리의 균형을 유지합니다. 

### 5.3.3 힙
힙은 완전 이진 트리 기반의 자료 구조로 자식 노드의 값이 부모 노드의 값보다 항상 크거나 항상 작은 특징을 가진 트리입니다. 이 때 자식 노드의 값이 크면 최소 힙, 반대의 경우 최대 힙이라고 부릅니다.

힙의 삽입은 새로운 노드를 힙의 가장 마지막에 삽입 한 후, 부모 노드와 값을 비교해 교환하는것으로 이루어집니다. 

힙의 삭제는 루트 노드의 삭제입니다. 루트 노드가 삭제되고 빈 루트는 가장 끝의 노드가 대신하고, 다시 자식 노드들과 값을 비교해 교환하는것으로 이루어집니다. 

### 5.3.4 우선순위 큐
우선순위 큐는 우선순위가 가장 높은 요소가 가장 먼저 제공되는 자료구조입니다. 우선순위 큐는 힙을 기반으로 구현됩니다. 



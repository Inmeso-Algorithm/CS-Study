# 3. 운영체제
운영체제(OS, Operating System)는 사용자가 컴퓨터를 쉽게 다루게 해주는 인터페이스라고 합니다. 컴퓨터의 전반적인 시스템 상에서의 운영체제의 역할을 그게 두가지로 나누어 볼 수 있습니다.   
1. 컴퓨터의 하드웨어들을 관리
2. 응용 프로그램들의 실행을 관리

이러한 두 가지 관점에서 운영체제가 어떤 방식으로 자신의 역할을 수행하는지 살펴볼 것입니다.   

*운영체제와 커널(Kernel)*   
- 커널은 운영체제안에 속해있는 구성요소 중 하나로 주로 메모리 관리나 디스크 I/O 관리 등 하드웨어 관리에 집중된 시스템 프로그램입니다.  
 
- 커널을 포함해 전반적인 컴퓨터 시스템을 담당하는 프로그램이 운영체제 입니다.

---

## 3.1 운영체제와 컴퓨터
### 3.1.1 운영체제의 역할과 구조
### 운영체제의 역할
운영체제의 역할은 다시 4가지로 세분화될 수 있습니다.
- CPU 스케줄링과 프로세스 관리
- 메모리 관리
- 디스크 파일 관리
- I/O 디바이스 관리

### 운영체제의 구조
![image](https://user-images.githubusercontent.com/103945439/187126936-f3853a7d-b7dd-461f-a3dd-8aac1dabc650.png)

운영체제는 많은 구성요소로 이루어져 있지만 기본적으로 유저 프로그램과 하드웨어 사이에 위치해 있습니다.

### 시스템콜
모든 컴퓨터의 하드웨어들은 운영체제가 관리합니다. 사용자 프로그램이 하드웨어를 사용하고자 할 때에도, 사용자 프로그램이 바로 접근 할 수 없고 운영체제를 거쳐서 사용하게 됩니다.

사용자 프로그램이 하드웨어에 접근하는 방법이 바로 시스템콜 입니다. 사용자 프로그램이 I/O 요청으로 트랩(trap)을 발동하면 운영체제는 이것이 올바른 요청인지 확인한 후 유저 모드가 커널 모드로 변환되어 실행됩니다.

*인터럽트(Interrupt)란?*   

인터럽트란 CPU가 작업을 처리하던 중 처리해야할 이벤트가 발생하여 CPU에 알려 처리하도록 하는 신호입니다. 처리해야 할 이벤트의 특성에 따라 하드웨어 인터럽트와 소프트웨어 인터럽트로 나뉩니다.

**하드웨어 인터럽트**   

통상적으로 우리가 인터럽트라고 부르는 것들은 하드웨어 인터럽트를 의미합니다. 하드웨어 인터럽트에는 다음과 같은 특징들이 있습니다.
- Asynchronous interrupt(비동기식 인터럽트)
- I/O device와 같은 하드웨어에서 발생

![image](https://user-images.githubusercontent.com/103945439/187339377-38c05d43-4877-4df0-b5cd-4e2adba70099.png)
하드웨어 인터럽트의 가장 대표적인 예시인 Keyboard**Interrupt** (ctrl^C)


**소프트웨어 인터럽트**   

소프트웨어로부터 발생하는 이벤트에 대한 인터럽트를 소프트웨어 인터럽트라고 합니다. 소프트웨어 인터럽트와 트랩은 CPU 제조사마다 정의에 있어 약간의 차이가 있지만 사실상 거의 같은 의미로 쓰입니다. 소프트웨어 인터럽트에는 다음과 같은 특징들이 있습니다.
- Synchronous interrupt(동기식 인터럽트)
- 소프트웨어로부터 발생
- 예외(Exception)와 시스템 콜 등이 대표적인 소프트웨어 인터럽트

![image](https://user-images.githubusercontent.com/103945439/187340125-a860a35f-839b-4562-8da1-49ef140b614d.png)
소프트웨어 인터럽트중 하나인 예외 (ZeroDivisionError)

### 유저 모드와 커널 모드
현 시대의 운영체제들은 dual-mode operation을 지원합니다. 이것은 유저 모드와 커널 모드를 나누어 두 모드간에 차이를 두는것을 의미하고, `modebit`를 이용해 구현되어집니다.

### modebit
modebit는 0또는 1의 값을 가지는 플래그 변수입니다. 운영체제는 시스템콜이 호출될 때 이 modebit를 참고하여 유저 모드와 커널 모드를 구분합니다.

![image](https://user-images.githubusercontent.com/103945439/187342405-7ce031d3-7eab-4673-81ba-97cd1ff6da5c.png)

사용자 프로그램이 하드웨어에 접근하고자 할 때는 반드시 시스템콜을 호출해 운영체제의 도움을 받아야합니다. 사용자 프로그램은 필요 시 시스템콜을 호출하고, 운영체제에서는 modebit를 0으로 바꿔 커널 모드에 진입했음을 의미하고 호출된 시스템콜을 실행합니다. 시스템콜 수행이 완료되고 반환 시 modebit는 다시 1로 바뀌어 유저모드로 돌아왔음을 의미하게 합니다.

운영체제가 수행하는 명령어에는 자칫 잘못 사용될 경우 치명적인 오류를 일으킬수 있는 명령어들도 존재합니다. 예를 들면 direct I/O access나 register 접근 등이 있습니다. 이러한 명령어들을 `Privileged instruction`이라고 합니다. 

Privileged instruction은 kernel mode 상태에서만 실행될 수 있습니다. User mode인 경우 실행되지 않습니다. 이렇게 함으로써 사용자 프로그램이 함부로 하드웨어에 접근하는것을 막을 수 있습니다.

---

### 3.1.2 컴퓨터의 요소
컴퓨터는 CPU, DMA 컨트롤러, 메모리, 타이머, 디바이스 컨트롤러 등으로 이루어져 있습니다.

#### CPU
CPU(Central Processing Unit)는 산술논리연산장치, 제어장치, 레지스터로 구성되어 있는 컴퓨터 장치를 말합니다.

#### 제어장치
제어장치(Control Unit)는 프로세스 조작을 지시하는 CPU의 한 부품입니다. 입출력장치 간 통신을 제어하고 명령어들을 읽고 해석하며 데이터 처리를 위한 순서를 결정합니다.

#### 레지스터
레지스터는 CPU 안에 있는 매우 빠른 임시기억장치를 가리킵니다. CPU와 직접 연결되어 있어 연산속도가 메모리보다 월등히 빠릅니다. CPU는 자체적으로 데이터를 저장할 수 없기 때문에 레지스터를 거쳐 데이터를 전달합니다.

#### 산술논리연산장치
산술논리연산장치(ALU, Arithmetic Logic Unit)는 산술 연산과 논리 연산을 계산하는 디지털 회로입니다.

#### DMA 컨트롤러
DMA 컨트롤러는 I/O 디바이스가 메모리에 직접 접근할 수 있도록 하는 하드웨어 장치를 뜻합니다. DMA가 I/O transfer를 전담하므로 그 동안 CPU에서는 다른 일을 처리할 수 있어 효율적입니다.

#### 메모리
메모리(Memory)는 전자회로에서 데이터나 상태, 명령어 등을 기록하는 장치를 말하면 보통 RAM(Random Access Memory)를 일컬어 메모리라고 합니다.

## 3.2 메모리
---
### 3.2.1 메모리 계층
메모리 계층은 레지스터, 캐시, 메모리, 저장장치로 구성되어 있습니다.
![image](https://user-images.githubusercontent.com/103945439/187596389-8731266f-6800-4784-856e-e8bcd9b42616.png)

각 저장장치들은 속도, 비용(또는 용량), 휘발성과 같은 특징에서 차이점이 있습니다.   

**레지스터**
- CPU 내부에 있는 작은 메모리이며, 접근 속도가 가장 빠르지만 기억용량은 가장 적고 휘발성입니다.

**캐시**
- L1, L2 캐시를 지칭하며, 속도가 빠르나 휘발성이며 기억용량은 적습니다.

**주기억장치**
- 메모리(RAM)을 가리키며, 보통의 속도와 보통 수준의 기억용량을 가지고 있으며 휘발성입니다.

**보조기억장치**
- 하드디스크(HDD)와 SSD를 일컬으며 속도가 느리지만 용량이 많으며 비휘발성입니다.   


위와 같이 메모리 계층이 있는 이유는 경제성과 캐시 때문입니다. 상위 계층일수록 속도가 빠르지만 그만큼 단위용량당 비용이 비싸집니다. 평소에는 용량이 크고 저렴한 하드디스크와 같은 보조기억장치에 데이터를 저장해두었다가, 프로그램 실행 시 이를 메모리에 로드해 빠르게 사용할 수 있게끔 하는것이 휠씬 효율적일것입니다.


#### 캐시
캐시(cache)는 데이터를 미리 복사해 놓은 임시 저장소이자 빠른 장치와 느린 장치에서 속도 차이에 따른 병목 현상을 줄이기 위한 메모리를 말합니다. 이를 통해 데이터를 접근하는 시간이 오래 걸리는 경우를 해결하고 무언가를 다시 계산하는 시간을 절약할 수 있습니다.

#### 지역성의 원리
캐시를 직접 설정해야 하는 경우, 가장 자주 사용되는 데이터가 캐시되어 있는것이 유리할 것이고, 결국 자주 사용하는 데이터가 무엇인지 알아내는 것이 중요하다고 할 수 있습니다. 여기에는 지역성(Locality)를 근거로 알아내는 방법이 있습니다. 지역성은 크게 시간 지역성과 공간 지역성으로 나뉩니다.

**시간 지역성**   
시간 지역성은 최근 사용한 데이터에 다시 접근하려는 특성을 말합니다. 
   
**공간 지역성**   
공간 지역성은 최근 접근한 데이터와 근접한 공간 상의 데이터에 다시 접근하려는 특성을 말합니다.

#### 캐시 히트와 캐시 미스
미래에 어떤 데이터가 필요할지 완벽하게 예측하는 것은 불가능하므로 원하는 데이터가 캐시되어있지 않는 상황은 발생할수밖에 없습니다. 이렇게 원하는 데이터가 캐시에 존재하지 않는다면 `캐시 미스`가 발생하였다고 하며, 반대로 원하는 데이터가 존재하는 경우 `캐시 히트`라고 합니다.

---

## 3.2.2 메모리 관리
운영체제의 역할 중 가장 대표적인것이 바로 메모리 관리입니다. 한정된 메모리 자원으로 최대한의 성능을 끌어올리는 중요한 역할이라고 할 수 있습니다.

### 가상 메모리
가상 메모리(Virtual memory)는 메모리 관리 기법의 하나로 컴퓨터가 실제로 이용 가능한 메모리 자원을 추상화하여 이를 사용하는 사용자들에게 매우 큰 메모리로 보이게 만드는 것을 말합니다

가상 메모리 기법에 의해 가상으로 주어진 메모리 주소를 가상 주소(Logical address)라고 하며, 실제 메모리상에 있는 주소는 실제 주소(Physical address)라고 합니다. 가상 주소는 실제 주소로의 변환이 필요한데, 이는 메모리관리장치(MMU, Memory Management Unit)에서 수행합니다. 

### 페이지 폴트
가상 메모리 상에는 존재하나 실제로는 메모리에 로드되지 않은 데이터에 접근하는 상황이 발생했을때 페이지 폴트(Page fault)가 일어났다고 합니다. 운영체제는 이를 해결하기 위해 데이터를 메모리로 로드시켜 프로그램에 정상적으로 실행되게 해줍니다. 

페이지 폴트가 일어나 새로운 데이터를 올려야 하나 메모리 상에 더이상 공간이 없을 경우 기존의 데이터를 쫒아내고 새로운 데이터를 로드시킵니다. 이것을 스와핑(Swapping)이라고 합니다.

### 스레싱
만약에 너무 많은 프로그램이 동시에 실행된다면, 메모리에 로드되는 데이터의 양은 한정되어 있기 때문에 페이지 폴트의 빈도가 높아지고 이에 따라 스와핑도 굉장히 많이 일어나게됩니다.    

스와핑은 엄청난 오버헤드를 발생시키기 때문에, CPU의 이용률이 낮아지게 됩니다. 하지만 운영체제에서는 단편적으로 CPU가 마치 여유로운것 처럼 착각해 더 많은 프로세스를 메모리에 올리게 되므로 악순환이 반복되어 CPU의 이용률은 계속해서 떨어지게 됩니다. 이것을 스레싱(Thrashing)이 발생하였다고 합니다

스레싱을 해결하기 위한 방법으로는 메모리를 늘리거나 보조기억장치의 성능을 높은 것으로 교체하는 물리적인 방법이 있고, 작업 세트와 PFF(Page Fault Frequency)와 같은 논리적 방법이 있습니다.

### 메모리 할당
메모리 할당에는 크게 연속 할당과 불연속 할당으로 나뉩니다.

#### 연속 할당
연속할당은 하나의 프로세스를 연속적으로 할당하는것으로 마치 하나의 블록을 메모리에 올리는 형태가 됩니다.

![제목 없음](https://user-images.githubusercontent.com/103945439/188298436-6113c485-8d53-4170-882a-ba9efa198157.png)

연속 할당의 경우 한 프로세스를 메모리에 올릴 때 어떤 빈 공간에 올릴것인가에 대한 선택이 있습니다. 위 사진에서 1번 공간에 프로세스를 올리는 경우를 최초적합(First fit)이며, 2번의 경우 최적적합(Best fit)이며, 3번의 경우 최악적합(Worst fit)입니다. 

#### 불연속 할당
메모리를 연속적으로 할당하지 않는 불연속 할당은 현대의 운영체제가 쓰는 방법으로 불연속 할당인 페이징 기법 등이 있습니다. 메모리를 동일한 크기의 페이지로 나누고 프로그램마다 페이지 테이블을 두어 이를 통해 메모리에 프로그램을 할당하는 것입니다.

*페이징*   
페이징 기법은 하나의 프로세스를 페이지로 일정한 크기로 나누어 메모리의 서로 다른 위치에 할당하는 기법입니다. 외부 단편화가 없지만 내부 단편화의 문제가 있으며 메모리 주소 변환이 복잡해질 수 있습니다.

*세그멘테이션*   
세그멘테이션 기법은 프로세스의 구성 요소를 세그먼트의 단위로 프로세스를 나누어 메모리에 할당하는 기법입니다. 보안과 공유 측면에서 좋으나 홀 크기가 균일하지 않은 문제가 발생합니다.

### 페이지 교체 알고리즘
메모리는 한정되어 있기 때문에 스와핑이 많이 일어납니다. 스와핑의 횟수를 최소화하기 위한 많은 페이지 교체 알고리즘들이 있습니다.

#### 오프라인 알고리즘
스와핑을 할 때 가장 이상적인 것은 미래에 사용되지 않을 데이터를 메모리에서 쫒아내고 사용될 데이터를 미리 올리는 것일겁니다. 하지만 미래에 일어날 일을 예측하는 것은 불가능합니다. 오프라인 알고리즘은 실제로 존재하는 알고리즘은 아니지만, 다른 페이지 교체 알고리즘의 성능 비교 기준이 됩니다.

#### FIFO
FIFO(First In First Out) 가장 먼저 올라온 페이지를 교체가 필요한 시점에 가장 먼저 교체하는 알고리즘입니다. 가장 간단하지만, 스와핑의 횟수를 효율적으로 줄이지 못합니다.

#### LRU
LRU(Least Recently Used)는 참조가 가장 오래된 페이지를 쫒아내는 알고리즘입니다. 대체적으로 좋은 성능을 보여주지만, 구현에 있어서의 어려움이 존재합니다.

#### NUR
NUR(Not Used Recently)은 일명 clock 알고리즘이라고 하며 하나의 플래그 비트를 두어 마치 시계와 같이 페이지를 순차적으로 체크하면서 최근에 참조되지 않은(비트가 0인) 페이지를 쫒아내는 알고리즘입니다.

#### LFU
LFU(Least Frequently Used)는 가장 참조 횟수가 적은 페이지를 교체하는 알고리즘입니다.
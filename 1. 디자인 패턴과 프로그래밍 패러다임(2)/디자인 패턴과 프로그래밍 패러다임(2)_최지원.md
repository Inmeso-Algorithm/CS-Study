# 1.1 디자인 패턴
## 1.1.8 MVC 패턴
### MVC 패턴이란
- 한 애플리케이션을 Model, View, Controller의 세 가지 구성 요소로 구분하는 디자인 패턴을 MVC 패턴이라고 합니다.
### 각각의 구성요소의 의미
1. Model
  - Model은 애플리케이션의 순수한 데이터를 의미합니다. 애플리케이션 내의 상수나 변수, 또는 데이터베이스를 뜻합니다.
2. View
- View는 사용자에게 Model이 가지고 있는 데이터들을 표시해주는 방법을 담고 있습니다.
- View에서는 어떠한 데이터도 따로 가지고 있지 않아야 하며 Model에서 제공받은 데이터를 바꾸지 않아야 합니다.
3. Controller
- Controller는 Model과 View 사이에서 둘 사이를 잇는 다리 역할을 합니다.
- Controller는 View(또는 기타 외부 source)에서 일어난 event를 listen하여 해당 event에 맞는 동작을 실행합니다. 주로 Model의 메소드를 호출하게 됩니다.
### MVC 패턴의 예시
```c++
class StudentModel {
private:
	vector<int> totalCredits;
public:
	void addCredit(int credit) {
		this->totalCredits.push_back(credit);
	}
	vector<int> getTotalCredit() {
		return this->totalCredits;
	}
};
```
- 학생이 받은 학점(데이터)를 가지고 있는 Model 객체입니다. 데이터를 수정하고 내보내는 함수들이 있습니다.
```c++
class StudentView {
public:
	void printTotalCredit(int totalCredit) {
		cout << "Total credit: " << totalCredit << endl;
	}
};
```
- 학생이 받은 총 학점을 출력해서 사용자에게 보여주는 방법을 담고있는 View 객체입니다. 중요한 점은, 이 객체에는 학생의 총 학점을 계산하는 알고리즘이 담겨있지 않다는 것 입니다.
```c++
class StudentController {
private:
	StudentModel model;
	StudentView view;
public:
	StudentController(StudentModel model, StudentView view) {
		this->model = model;
		this->view = view;
	}
	void updateView() {
		vector<int> totalCredits = this->model.getTotalCredit();
		int total = 0;
		for (int credit : totalCredits) {
			total += credit;
		}
		this->view.printTotalCredit(total);
	}
	void updateModel(int credit) {
		this->model.addCredit(credit);
	}
};
```
- View와 Model을 이어줄 Controller 객체입니다. 이 객체 내부에는 Model에서 학점 데이터를 받아 이를 모두 더해 View 객체로 전달하는 간단한 알고리즘과 Model의 학점 데이터를 추가하는 메소드가 담겨져 있습니다.
### MVC 패턴의 장단점
1. 장점
- View, Model, Controller로 나뉘어져 있으므로 각각의 구성요소에 대해 집중적으로 개발할 수 있고, 동시에 개발 가능하므로 개발 속도가 빠릅니다.
- 각각의 구성요소가 서로 덜 의존하게 됨으로 결합도를 낮출 수 있게 됩니다. [(loose coupling)](https://www.leafcats.com/68)
2. 단점
- 애플리케이션이 커지고 이에대한 기능이 추가됨에 따라 많은 수의 View와 Model이 얽히게 되어 구조를 파악하기 어려워지게되고 View와 Model사이의 의존성 또한 점점 높아지게 됩니다.



---
## 1.1.9 MVP 패턴
### MVP 패턴이란
- MVP 패턴은 MVC 패턴으로부터 파생되었으며 MVC 패턴에서의 Controller가 Presenter로 교체된 패턴입니다.
- Controller가 여러개의 View와 연결할 수 있는 MVC 패턴과 다르게 MVP 패턴은 View와 Presenter가 일대일 관계에 있다는 점 입니다.
### MVP 패턴의 장단점
1. 장점
- 기존의 MVC 패턴이 가진 단점이였던 View와 Model사이의 높은 의존성을 해결하였습니다.
2. 단점
- View와 Presenter가 일대일 관계에 있어 이 둘 사이의 의존성이 높습니다.



---
## 1.1.10 MVVM 패턴
### MVVM 패턴이란
- NVVM 패턴 역시 MVC 패턴으로부터 파생되었으며 MVC 패턴에서의 Controller가 View Model로 바뀐 패턴입니다.
- Command 패턴과 data binding을 이용하여 View와 View model사이의 의존성을 없앴습니다.
### MVVM 패턴의 장단점
1. 장점
- MVC 패턴이 View와 Model사이의 의존성이 높았고 MVP 패턴이 View와 Presenter사이의 의존성이 높았지만 MVVM은 Model, View, Viw Model간의 의존성이 없습니다.
2. 단점
- 간단한 애플리케이션에서 오히려 더 설계에 어려움이 있을 수 있습니다. 이는 View Model을 설계하는것이 쉽지 않기 때문입니다. 
- 애플리케이션이 복잡해질수록 View Model이 비대해진다는 단점이 있습니다.


# 1.2 프로그래밍 패러다임
## 1.2.1 선언형과 함수형 프로그래밍
- 프로그래밍은 크게 선언형 프로그래밍과 명령형 프로그래밍으로 나누어집니다. 선언형 프로그래밍은 다시 함수형 프로그래밍이라는 하위 집합을 가지고 있습니다. 즉, 선언형 프로그래밍의 일종으로 함수형 프로그래밍이 있다고 할 수 있습니다.
### 선언형과 명령형 프로그래밍의 차이점
- 명령형 프로그래밍에서는, 어떠한 원하는 결과를 도출해내기 위한 과정이 작성됩니다. 입력값을 어떻게(how to) 가공하는 것에 대한 것에 초점이 맞춰져 있습니다.
```python
### 주어진 배열의 원소들에 2를 곱하고 1을 더한 새로운 배열을 출력하기
arr = [1, 3, 4, 7, 15, 26]
newArr = []
for num in arr:
    newArr.append(num * 2 + 1)
print(newArr) # [3, 7, 9, 15, 31, 53]
```
***명령형 프로그래밍**의 관점으로 작성한 예시*
- 선언형 프로그래밍에서는, 결과를 도출하기 위해 무엇(what)을 할 것인가에 초점이 맞춰져 있는 프로그래밍 사고방식입니다.
```python
### 주어진 배열의 원소들에 2를 곱하고 1을 더한 새로운 배열을 출력하기
arr = [1, 3, 4, 7, 15, 26]
print(list(map(lambda x : x * 2 + 1, arr))) # [3, 7, 9, 15, 31, 53]
print(arr) # [1, 3, 4, 7, 15, 26]
```
***선언형 프로그래밍**의 관점으로 작성한 예시*

### 함수형 프로그래밍의 특징
1. 부수효과와 순수 함수
- 함수형 프로그래밍에서의 부수효과(side effect)는, 원하는 결과를 도출하는 과정에서 발생하는 모든 변화를 지칭합니다. 변수의 값이 변한다던가, 입출력이 발생한다던가, 예외나 오류가 발생하여 프로그래밍 실행이 중단되는 상황 등이 부수효과의 예시입니다.
- 순수함수(pure function)는, 이러한 부수효과를 제거한 함수를 의미합니다.
1. 함수형 프로그래밍에서의 1급 객체
- 1급 객체란 변수나 구조체 안에 할당될 수 있고, 파라미터로 전달 될 수 있어야 하며, return value로 사용될 수 있어야 합니다. 객체지향 프로그래밍에서의 1급 객체는 클래스이지만, 함수형 프로그래밍에서의 1급 객체는 함수가 됩니다.

### 함수형 프로그래밍의 장단점
1. 함수형 프로그래밍의 장점
- 함수형 프로그래밍은 선언형 프로그래밍의 특성을 함수의 조합으로 구현한 것이므로 선언형 프로그래밍의 장점들을 가집니다. 선언형 프로그래밍의 가장 대표적인 장점으로 높은 수준의 추상화가 있습니다.
- 함수 단위의 코드 재사용성이 높습니다.
- 순수 함수의 특징인 부수 효과가 없다는 점에 근거하여, thread safety를 보장받습니다.
2. 함수형 프로그래밍의 단점
- 순수 함수를 구현한 코드는 가독성이 떨어집니다.
- 순수 함수를 조합하여 고차 함수를 구현하는 난이도가 매우 높습니다.
---
## 1.2.2 객체지향 프로그래밍
- 객체지향 프로그래밍은 객체들의 집합으로 프로그램의 상호 작용을 표현하며 객체와 그 객체 내부에 선언된 메소드를 활용하는 프로그래밍 방식입니다.
- 객체지향 프로그래밍의 중요한 특징들로 추상화, 캡슐화, 상속성, 다형성이 있습니다
### 추상화
- 추상화란 복잡한 개체로부터 어떤 영역에서 필요한 핵심 정보 또는 기능을 간추려내는것을 의미합니다.
- 개체를 추상화할때, 각 개체의 구체적인 개념에 의존해서는 안되고 추상적이고 더 일반적인 개념에 의존해야 합니다. 이렇게 함으로써 이후 설계를 유연하게 변경 할 수 있기 때문입니다.
### 캡슐화
- 캡슐화(encapsulation)는 객체 내부의 속성과 메소드를 외부로 노출시키지 않고 은닉함으로써 외부에서 접근하지 못하도록 제한하는 것을 의미합니다
- 캡슐화는 특히 낮은 결합도(cohesion)을 유지할 수 있도록 해주는 객체지향 설계 원리입니다. 두 클래스 사이의 결합도가 높다면 이들 중 하나의 클래스를 변경해야할 상황이 일어났을 때 다른 클래스 또한 변경해야 하는 상황이 생기게 됩니다. 캡슐화를 통해 서로 공유하지 않아야 할 변수나 메소드를 지정함으로써 낮은 결합도를 유지할 수 있는 것입니다.
### 상속성
- 상속성(inheritance)는 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용, 추가 또는 확장하는것을 말합니다.
- 상속을 해주는 상위 클래스는 더 일반적이고 추상적인 개념을 담고 있고, 상속을 받는 하위 클래스는 더 구체적인 개념을 담고 있습니다.
### 다형성
- 다형성(polymorphism)은 클래스 또는 메소드가 상황에 따라 다르게 동작될 수 있는 성질을 뜻합니다. 다형성을 구현하는 가장 대표적인 방법으로 오버로딩과 오버라이딩이 있습니다.
1. 오버로딩
- 오버로딩은 하나의 메소드를 parameter에 따라 다르게 구현되는 것을 의미합니다.
2. 오버라이딩
- 오버라이딩은 상위 클래스에 정의되어있던 메소드를 하위 클래스가 상속받아 이 메소드를 재정의하는것을 의미합니다.

### 설계 원칙
- 객체지향 프로그래밍에 있어서 지켜야할 설계 원칙으로 SOLID원칙이 있습니다. SOLID원칙은 각각 단일 책임 원칙, 개방-폐쇄 원칙, 리스코프 치환 원칙, 인터페이스 분리 원칙 그리고 의존 역전 원칙을 뜻합니다.
1. 단일 책임 원칙
- 단일 책임 원칙(Single resposibility principle)은 하나의 클래스는 하나의 책임만은 가져야 한다는 원칙입니다. 한 클래스가 많은 책임을 떠안게 된다면 클래스 내부의 메소드들이 서로 강한 의존성을 가지게 될 수 있고 이는 클래스의 유지 보수를 어렵게 합니다.
- 역으로 여러 개의 클래스가 하나의 책임을 가지는 경우도 있는데, 이러한 경우 역시 단일 책임 원칙에 입각해 설계를 변경해야 합니다. 이러한 상황을 지칭하는 용어로 산탄총 수술(shotgun surgery)라는 용어가 있습니다. 산탄총 수술이 위험한 이유는 수술 부위가 많다는 것 뿐만 아니라 모든 총알을 찾아서 제거하지 않으면 수술은 실패한다는 점 입니다. 여러 개의 클래스에 책임이 분산된 경우도 마찬가지로, 프로그램에 수정이 필요할 때 이 클래스들을 모두 변경하지 않으면 프로그램이 정상적으로 작동하지 않을 것입니다.
2. 개방-폐쇄 원칙
- 개방-폐쇄 원칙(Open closed principle)은 프로그램의 유지 보수에 있어 확장에 대해서는 열려 있고 수정에 대해서는 닫혀 있어야만 한다는 원칙입니다. 쉽게 말해서 새로운 기능의 추가는 기존의 코드에 수정을 가하지 않으면서도 쉽게 가능하게 되어야 한다는 뜻입니다.
3. 리스코프 치환 원칙
- 리스코프 치환 원칙(Liskov substitution principle)은 클래스가 상속되고 상속됨에 따라 정해지는 계층 관계에 있어서 하위 클래스는 적어도 상위 클래스에서 가능한 행위를 수행할 수 있어야 한다는 원칙입니다. 즉, 상위 클래스와 하위 클래스 사이의 행위에는 일관성이 있어야만 한다는 뜻입니다.
4. 인터페이스 분리 원칙
- 인터페이스 분리 원칙(Interface segregation principle)은 하나의 일반적인 인터페이스를 만들기보다 구체적인 여러 개의 인터페이스를 만들어야 한다는 원칙을 말합니다.
5. 의존 역전 원칙
- 의존 역전 원칙(Dependency inversion principle)은 의존 관계를 맺을 때 자주 변화하는 것에 의존하기 보다 변화하기 어려운 것에 의존하라는 원칙입니다.
- 구체적인 구현이 있는 클래스보다 추상 클래스나 인터페이스에 의존하는 것이 의존 역전 원칙을 지키는 것이며 변화에 유연한 시스템이 됩니다.
---
## 1.2.3 절차형 프로그래밍
- 절차형 프로그래밍은 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있습니다. 
- 단순히 계산 과정을 일련의 코드로 구현하기 때문에 가독성이 좋고 실행 속도가 빠릅니다. 따라서 많은 계산을 필요로 하는 작업에 쓰입니다.
- 일련의 절차를 나열한 코드이므로 모듈화하기 어렵고 유지 보수하기 힘듭니다.


---
## 1.2.4 패러다임의 혼합



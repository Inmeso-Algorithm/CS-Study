# 디자인 패턴과 프로그래밍 패러다임 (2)

## 목차

### 1.1 디자인 패턴

- 1.1.8 MVC 패턴
- 1.1.9 MVP 패턴
- 1.1.10 MVVM 패턴

### 1.2 프로그래밍 패러다임

- 1.2.1 선언형과 함수형 프로그래밍
- 1.2.2 객체지향 프로그래밍
- 1.2.3 절차형 프로그래밍

### ☆추가적으로 나온 질문 목록

- MVC 패턴의 장, 단점 (구체적으로)

- MVC, MVP, MVVM의 차이 (구체적으로)

- 함수형 프로그래밍의 장단점 (구체적으로)

  - 가독성이 좋은지? 그 이유는

- 객체지향 프로그래밍
  - SOLID의 D에 대한 구체적인 설명

---

## 1.1.8 MVC 패턴

MVC 패턴은 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴이다.

애플리케이션의 구성 요소를 세 가지 역할로 구분함

**Model** : 애플리케이션의 데이터인 데이터베이스, 상수, 변수 등과 데이터를 처리하는 부분

- 뷰나 컨트롤러에 대해 어떤 정보도 알지 말아야 한다.
- 사용자가 편집하길 원하는 모든 데이터를 가지고 있어야만 한다.

**View** : 사용자 인터페이스 요소, 사용자가 볼 수 있는 화면

- model을 controller로부터 받아와 사용자에게 시각적으로 보여준다.
- model이 가지고 있는 정보를 따로 저장해서는 안된다.

**Controller** : 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할과 이벤트 등 메인 로직을 담당

- 모델이나 뷰에 대해서 알고있어야 하고 변경을 모니터링해야 한다.
- 사용자에게 데이터를 뷰를 통해서 보여준다.
- 사용자가 이용해 제어할 수 있게 만들어주는 부분이다.

장점 : 서로 분리되어서 각각의 역할만 담당함으로써 유지보수성, 애플리케이션의 확장성, 그리고 유연성이 증가하고, 중복코딩이 사라진다.

단점 : 뷰와 모델 사이의 의존성이 높다. 높은 의존성은 어플리케이션이 커질수록 복잡해지고, 유지보수가 어렵다.

![단점](https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FAausY%2FbtrhMd9GH8p%2FSHi1qjRtb44akClxGYXFw0%2Fimg.png "단점의 시각화")

참고 : [생활코딩 - MVC 디자인 패턴](https://opentutorials.org/course/697/3828)

## 1.1.9 MVP 패턴

MVC패턴에서 파생되었고 Controller가 프레젠터(Presenter)로 교체된 패턴이다.

**Presenter** : View와 Model을 연결해주는 역할, UI 로직과 비즈니스 로직을 분리
뷰와 프레젠터는 일대일 관계이다.

장점 : 뷰와 모델 사이에 presenter라는 연결부분을 두어 MVC 패턴의 단점인 의존성을 보완했다.

단점 : 1대1관계를 유지해야해서 뷰가 많아질수록 프레젠터도 자연스럽게 많아질 수밖에 없다.
뷰와 모델을 연결시켜주기 때문에 애플리케이션 기능이 추가될때마다 프레젠터 내의 코드가 많아진다.

### ☆MVC와 MVP에서 Controller와 Presenter의 차이

![](https://velog.velcdn.com/images%2Fdin0121%2Fpost%2F0329d7ab-089a-4303-8795-d28763962c4b%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-12-17%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.21.34.png) ![](https://velog.velcdn.com/images%2Fdin0121%2Fpost%2Fb7988e2f-3609-4c4c-a4c4-3e5eacc6ed6a%2F%E1%84%89%E1%85%B3%E1%84%8F%E1%85%B3%E1%84%85%E1%85%B5%E1%86%AB%E1%84%89%E1%85%A3%E1%86%BA%202020-12-17%20%E1%84%8B%E1%85%A9%E1%84%92%E1%85%AE%207.40.54.png)

|                       | Controller-MVC                                    | Presenter-MVP                                               |
| --------------------- | ------------------------------------------------- | ----------------------------------------------------------- |
| 진입점                | 애플리케이션의 진입점은 Controller                | 애플리케이션의 진입점은 View                                |
| View와의 관계         | Controller 1 : 다수 Views                         | View 1 : 1 presenter                                        |
| View의 참조 관계      | View에 Controller에 대한 참조가 없음              | Presenter에 View에 대한 참조가 존재                         |
| View에 영향을 주는 것 | Controller, Model                                 | Input, Presenter                                            |
| 뷰 업데이트 방법      | Controller가 하지 않음, View와 Model사이에서 해결 | Presenter가 뷰와 모델 둘 다 함                              |
| 단점                  | 단위 테스트가 어려움                              | 앱이 복잡해 질 수록 View와 Presenter 사이의 의존성이 강해짐 |

MVC에서 MVP로 바뀌면서 view와 model간의 직접 연결이 없어지면서 둘 사이의 의존성은 약화되었지만,View에서 Presenter를 직접 생성하기에 둘 사이의 의존성이 높아졌고 1:1 관계를 유지해야 해서 View가 많아질수록 Presenter도 자연스럽게 많아질 수밖에 없다.
또한 View와 Model을 연결시켜주는 역할이 Presenter이기에 애플리케이션 기능이 추가될 때마다 Presenter 내의 코드가 많아진다는 단점도 있다.

참고 : [MVC MVP 비교](https://velog.io/@din0121/Design-Pattern-MVC-MVP-MVVM-%EB%B9%84%EA%B5%90)

## 1.1.10 MVVM 패턴

MVC패턴에서 파생되었고 Controller가 뷰모델(View Model)로 바뀐 패턴이다.

**View Model** : View에서 표현해야할 데이터를 Observable 타입으로 관리하며 View들이 ViewModel의 데이터를 구독 요청하여 화면을 갱신

- 장점 : View와 Model 사이의 의존성이 없다.
  View와 View Model 사이의 의존성이 없다.
  한쪽 방향으로만 의존 관계가 있어서 분리개발이 가능하다.

- 단점 : View-Model의 설계가 쉽지 않다.
  Databinding, LiveData 등 다른 라이브러리를 필수적으로 알아야 사용할 수 있다.

---

# 1.2 프로그래밍 패러다임

프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 개발 방법론이다.

      프로그래밍 패러다임의 분류
          -선언형
              1.함수형
          -명령형
              1.객체지향형
              2.절차지향형

## 1.2.1 선언형과 함수형 프로그래밍

선언형 프로그래밍은 **무엇을** 풀어내는가에 집중하는 패러다임이다. 함수형 프로그래밍은 선언형 패러다임의 일종이다.

특징 : 작은 '순수 함수' 들을 블록처럼 쌓아 로직을 구현하고 '고차 함수'를 통해 재사용성을 높인다.

순수함수 : 출력이 입력에만 의존하는 함수,동일한 입력엔 항상 같은 값을 반환한다.
함수의 실행이 함수 내부에서 인자나 프로그램을 변경하는 등의 Side effect를 일으키지 않는 함수

ex)

```
//들어오는 매개변수에만 영향을 받음, 전역변수등에 영향을 받지 않음

const pure =(a,b)=>{
    return a+b
}

```

고차함수 : 함수가 함수를 값처럼 배개변수로 받아 로직을 생성할 수 있는 것

->쓰기위한 조건 : 해당 언어가 일급 객체

일급 객체

- 변수나 메서드에 함수 할당 가능
- 함수 내부에 함수를 매개변수로 담기 가능
- 함수가 함수 반환 가능
- 할당에 사용된 이름과 관계없이 고유한 구별이 가능
- 동적으로 프로퍼티 할당이 가능

불변성

- 함수형 프로그래밍에서는 데이터가 변할 수 없는데, 이를 불변성 데이터라고 한다. (자바스크립트는 가능하지만 불가능한 언어들이 있다)
- 데이터 변경이 필요한 경우, 원본 데이터 구조를 변경하지 않고 그 데이터를 복사본을 만들어 그 일부를 변경하고, 변경한 복사본을 사용해 작업을 진행한다.

### ☆함수형 프로그래밍의 장단점

함수형 프로그래밍의 컨셉 : 변경 가능한 상태를 불변상태로 만들어 sideeffect를 없애자, 동시성 작업의 안전한 구현

언어에 따라 제약도 많다.

장점

1. 높은 수준의 추상화를 제공한다.

   (추상화 : 복잡한 무언가에서 핵심적인 개념이나 기능을 간추려내어 단순하게 만드는 것)

2. 함수 단위의 코드 재사용이 수월하다.
3. 불변성을 지향하기 때문에 프로그램의 동작을 예측하기 쉬워진다.
4. 객체보다 더 작게 쪼개서 생각 할 수 있다.

단점

1. 순수함수의 구현에서 가독성이 떨어질 수 있다.
2. 함수형 프로그래밍에서는 반복이 for문이 아닌 재귀를 통해 이루어지는데 (deep copy), 재귀적 코드 스타일은 무한 루프에 빠질 수 있다.
3. 순수함수를 사용하는 것은 쉬울 수 있지만 조합하는 것은 쉽지 않다.
4. 제약이 많다.

참고 자료

- [함수형 프로그래밍이란?](https://jongminfire.dev/%ED%95%A8%EC%88%98%ED%98%95-%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D%EC%9D%B4%EB%9E%80)
- [함수형 프로그래밍의 장점 그리고 예제](https://easywritten.com/post/real-advantages-of-functional-programming/)
- [명령형 함수형 변환](https://opentogether.tistory.com/76)

## 1.2.2 객체지향 프로그래밍

객체지향 프로그래밍은 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 메서드를 활용하는 방식을 말한다.

### 특징 : 추상화, 캡슐화, 상속성, 다형성

- 추상화(abstraction)

  - 공통의 속성이나 기능을 묶어 이름을 붙이는 것이다.
  - 예를 들자면 고양이, 개, 돼지 라는 객체가 존재한다고 가정했을 때 이 객체들을 크게 추상적인 개념인 '동물' 이라고 묶는 것을 추상화라고 한다.

- 캡슐화(encapsulation)
  객체의 속성과 메서드를 하나로 묶고 내부의 정보를 외부로 최소한만 보여주는 특성이다.

- 상속성(inheritance)
  상위 클래스의 특성을 하위 클래스가 이어받아서 재사용 할 수 있는 특성이다.

- 다형성(polymorphism)

  - 하나의 타입에 여러 객체를 대입할 수 있는 성질
  - 오버로딩, 오버라이딩이 존재한다.

  - 오버로딩(overloading) :
    같은 이름을 가진 메서드를 여러 개 두는 것을 말한다.
    메서드의 타입, 매개변수의 유형,개수 등으로 여러 개를 둘 수 있다.
    컴파일 중에 발생하는 '정적'다형성이다.

  - 오버라이딩(overriding) :
    주로 메서드 오버라이딩(method overriding)을 말하며 상위클래스로부터 상속받은 메서드를 하위 클래스가 "재정의" 하는 것을 의미한다.
    런타임중에 발생하는'동적'다형성이다.

### 설계원칙에는 **SOLID**원칙이 있다.

- S : 단일 책임 원칙(SRP, Single Responsibility Principle)
  모든 클래스는 반드시 하나의 책임만 가져야 한다.

- O : 개방 폐쇄 원칙(OCP, Open Closed Principle)
  기존의 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 한다.

- L : 리스코프 치환 원칙(LSP, Liskov Substitution Principle)
  부모 객체와 이를 상속한 자식 객체가 있을 때 부모 객체를 호출하는 동작에서 자식 객체가 부모 객체를 완전히 대체할 수 있어야 한다.

  관련 자료 : [리스코프 치환 원칙을 준수, 준수하지 않은 코드](https://blog.itcode.dev/posts/2021/08/15/liskov-subsitution-principle)

- I : 인터페이스 분리 원칙(ISP, Interface Segregation Principle)
  하나의 일반적 인터페이스보다 여러개의 구체적 인터페이스를 만들어야 한다.

- D : 의존 역전 원칙(DIP, Dependency Inversion Principle)
  상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다.

### ☆ 의존역전원칙에 대한 추가 설명

1. 고수준 모듈(혹은 클래스)이 저수준 모듈(혹은 클래스)에 의존하지 말아야 한다. 즉, 둘 다 추상화에 의존해야 한다.
2. "추상화는 세부사항(즉, 구현)에 의존해서는 안된다.". 구현이 변경되더라도 추상화가 변경되면 안된다는 뜻입니다. 다시 말해서 특정 구현을 먼저 보고 추상화를 떠올리면 이와 같은 일이 벌어질 수 있으며, 향후에 새로운 구현을 추가하게 되더라도 추상화가 변경되지 말아야 합니다.
3. "세부사항이 추상화에 의존해야 한다."인데 휴대폰의 볼륨 업 버튼을 딸깍 눌렀더니 볼륨이 낮아지거나, 볼륨이 갑자기 한 칸이 아닌 세 칸이 올라간다던가, 휴대폰 전원이 꺼지는 예상치 못한 일이 일어나서는 안 된다는 말입니다.

참고 자료 : [의존관계 역전 법칙](https://blog.hexabrain.net/395)

## 1.2.3 절차형 프로그래밍

절차형 프로그래밍은 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있다.

순차적인 처리를 중요시 여기며, 프로그램 전체가 유기적으로 연결되도록 만드는 프로그래밍 기법이다.
계산이 많은 작업 등에 주로 쓰인다.

장점 : 순차적 구현으로 코드의 가독성이 좋다.
컴퓨터의 처리구조와 유사해 실행 속도가 빠르다.

단점 : 유지보수가 어렵다.
순서가 바뀌면 결과값을 보장할 수 없다.
코드가 길어지면 가독성이 무척 떨어진다.

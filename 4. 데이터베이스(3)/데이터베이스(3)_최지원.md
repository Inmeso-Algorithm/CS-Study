# 4.4 데이터베이스의 종류
## 4.4.1 관계형 데이터베이스
관계형 데이터베이스는 행과 열을 가지는 표 형식 데이터를 저장하는 형태의 데이터베이스를 가리키며 SQL이라는 언어를 써서 조작합니다. 대표적으로 MySQL, PostgreSQL 등이 있습니다. 

## 4.4.2 NoSQL 데이터베이스
Not only SQL이라는 슬로건에서 생겨난 데이터베이스입니다. SQL을 사용하지 않는 데이터베이스를 말하며 대표적으로 MongoDB와 redis등이 있습니다. 

# 4.5 인덱스
## 4.5.1 인덱스의 필요성
인덱스는 데이터를 빠르게 찾을 수 있는 하나의 장치입니다. 책에 맨 뒤에 있는 찾아보기와 비슷한 개념이라고 할 수 있습니다. 책의 본문 안의 특정한 개념이나 단어를 빠르게 찾을수 있듯이 인덱스도 데이터베이스에서 원하는 데이터를 빠르게 찾을 수 있도록 합니다. 


## 4.5.2 B+ tree
![image](https://user-images.githubusercontent.com/103945439/193001874-782ae17a-d3d9-40cc-be62-e1a7f1d5d893.png)

MySQL, PostgreSQL 등을 포함한 대부분의 데이터베이스 시스템에서 인덱스는 보통 B+ tree라고하는 자료구조로 이루어져 있습니다.

B+ tree에는 다음과 같은 특성을 가지고 있습니다.   
- 루트에서 리프 노드까지의 경로의 길이는 모두 같다
- 루트나 리프가 아닌 노드의 자식 노드의 수는 [n/2, n]개로 한정된다
- 리프 노드의 값은 [(n-1)/2, n-1]로 한정된다

B+ tree는 삽입 또는 삭제 연산 수행 시 위와 같은 조건들을 만족시키기 위해 노드들의 Merge와 Split이 일어나고, 이러한 과정을 통해 트리 구조의 균형을 유지하여 대수확장성을 유지합니다.

참고로 B+ tree는 NTFS와 ext4와 같은 file system에서도 쓰입니다.

*대수확장성이란?*   
>대수확장성이란 트리 깊이가 리프 노드 수에 비해 매우 느리게 성장하는 것을 의미합니다.

## 4.5.3 인덱스 만드는 방법
인덱스를 생성하는 방법은 데이터베이스마다 다르며 이에 따른 인덱싱의 방식에도 약간의 차이가 있습니다.

**클러스터형 인덱스**   
클러스터형 인덱스는 primary 인덱스라고도 불리며 형태는 다음과 같습니다.
![image](https://user-images.githubusercontent.com/103945439/193004949-c0bc61e4-9788-468f-8568-2f51ce33e173.png)


**세컨더리 인덱스**   
세컨더리 인덱스는 일종의 보조 인덱스로 여러 개의 필드 값을 기반으로 쿼리를 많이 보낼 때 생성하는 인덱스입니다.
![image](https://user-images.githubusercontent.com/103945439/193004545-2d2ac4f7-2afc-4a9e-889c-3dc4a79c9436.png)


### 인덱스 최적화 기법
#### 인덱스와 비용
인덱스의 구조에서 보았듯이 인덱스를 탐색하는데 필요한 일정한 비용이 있습니다. 또한, 인덱스의 삽입과 삭제 연산과 관련해서도 균형을 유지하기 위한 유지보수 비용이 소모됩니다. 그렇기에 쿼리에 있는 모든 필드에 인덱스를 설정하는 것은 비효율적입니다. 이러한 점을 고려하여 인덱스를 설정해야 할 것입니다.

#### 테스팅
인덱스의 최적화는 서비스 특징에 따라 달라집니다. 따라서 항상 테스팅하는것이 중요하다고 할 수 있습니다. MySQL에서는 EXPLAIN과 같은 키워드를 이용해 테스팅을 수행할 수 있습니다.

#### 복합 인덱스의 순서
1. == 과 equal이라는 쿼리가 있다면 이에 해당하는 필드를 인덱스로 설정함.
2. 정렬에 사용되는 필드를 인덱스로 설정함.
3. 부등호와 같은 연산이 있어 다중 값을 출력해야한다면 인덱스로 설정함.
4. Cardinality를 기반으로 인덱스를 설정함.


# 4.6 조인의 종류
조인(join)이란 하나의 테이블이 아닌 두 개 이상의 테이블을 묶어서 하나의 결과물을 만드는 것을 말합니다.

## 4.6.1 내부 조인
내부 조인은 두 테이블 간에 교집합을 나타냅니다.

## 4.6.2 왼쪽 조인
왼쪽 조인은 테이블 B의 일치하는 부분의 레코드와 함께 테이블 A를 기준으로 완전한 레코드 집합을 생성합니다. 만약 테이블 B에 일치하는 항목이 없으면 해당 값은 null값이 됩니다.

## 4.6.4 합집합 조인
합집합 조인(Full outer join)은 양쪽 테이블에서 일치하는 레코드와 함께 테이블 A와 테이블 B의 모든 레코드 집합을 생성합니다. 이때 일치하는 항목이 없으면 누락된 쪽에 null값이 포함되어 출력됩니다.

# 4.7 조인의 원리
앞서 설명한 조인은 조인의 원리를 기반으로 조인 작업이 이루어집니다. 각 조인의 방법마다 장단점이 있으며 조인의 성격과 조인 원리의 디스크 i/o 복잡도에 따라 성능이 상이합니다.

일반적으로 데이터베이스는 매우 큰 데이터를 다루며, 이는 즉 데이터가 메모리에 올라갈수 있는 가용량보다 크다는 것을 의미합니다. 따라서 데이터베이스는 데이터를 블록이라는 작은 단위로 쪼개서 메모리에 로드하게 됩니다.

External disk의 i/o는 CPU 연산이나 기타 다른 연산에 비해 압도적으로 많은 시간이 소모된다고 잘 알려져 있습니다. 이것은 즉 disk i/o를 기준으로 조인의 성능이 결정된다고 할 수 있습니다.

## 4.7.1 중첩 루프 조인
중첩 루프 조인은 2중 for 문과 같은 원리로 조건에 맞는 조인을 하는 방법입니다. 

두개의 테이블을 중첩 루프 조인할 때 조건 연산을 위해 각 테이블에서 순서대로 각 튜플이 속한 블록을 메모리로 로드할 것입니다. 

이러한 방식으로 모든 튜플을 선형적으로 연산하게 된다면, 최악의 경우 각 튜플의 블록이 모두 제각각이라 한번의 튜플 연산마다 하나의 블록을 메모리로 로드해야 할 것입니다. 이것을 i/o complexity로 표현하면, 
**O(N1 * N2/B) ~= O(N^2/B)** 로 표현할 수 있습니다. 

연산의 순서를 튜플 기준이 아닌 블록의 기준으로 하는 조인 방식으로 블록 중첩 루프 조인이 있습니다. 이 조인 연산의 i/o complexity는 **O(N^2/B^2)** 으로 다소 개선된 방식이라고 할 수 있습니다.

## 4.7.2 정렬 병합 조인
정렬 병합 조인(sorted merge join)이란 각각의 테이블을 조인할 필드 기준으로 정렬하고 정렬이 끝난 이후에 조인 작업을 수행하는 조인입니다. 튜플이 정렬되었으므로 각 튜플은 단 한번의 block load만으로 자신이 필요한 연산을 하고 더 이상 load될 일이 없습니다. 따라서 i/o complexity는 **O(N1/B + N2/B) ~= O(N/B)** 로 표현할 수 있습니다. 

## 4.7.3 해시 조인
해시 조인은 해시 테이블을 기반으로 조인하는 방법입니다. 해시 조인은 우선 두 테이블 중 크기가 작은 테이블을 기준으로 조인에서 사용되는 필드의 데이터를 해시된 키가 매핑됩니다. 이후 조인 연산 수행 시 해시 테이블을 이용하여 인메모리에서 필드를 찾을 수 있습니다. 